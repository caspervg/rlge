#include <print>

#include "debug.hpp"
#include "engine.hpp"
#include "imgui.h"
#include "sprite.hpp"
#include "transformer.hpp"
#include "render_entity.hpp"

using namespace rlge;

class FpsCounter final : public RenderEntity {
public:
    explicit FpsCounter(Scene& scene) : RenderEntity(scene) {}

    void draw() override {
        rq().submitUI([] {
            DrawFPS(10, 10);
        });
    }
};
// Background entity that draws a wide patterned image so movement is obvious.
class Background final : public RenderEntity {
public:
    explicit Background(Scene& scene, Texture2D& texture)
        : RenderEntity(scene)
        , texture_(texture) {}

    void draw() override {
        if (!visible_)
            return;
        // Draw at world origin; the camera moving will reveal different parts.
        rq().submitBackground([this] {
            DrawTexture(texture_, -texture_.width / 2, -texture_.height / 4, WHITE);
        });
    }

private:
    Texture2D& texture_;
    bool visible_ = true;

    friend class GameScene;
};

// Simple player entity that can move left/right/rotate and is followed by the camera.
class Player final : public RenderEntity {
public:
    explicit Player(Scene& scene, Texture2D& texture)
        : RenderEntity(scene) {
        auto& tr = add<rlge::Transform>();
        tr.position = {100.0f, 200.0f};

        auto& anim = add<SpriteAnim>(texture, 32, 32);
        anim.loadStrip(0, 4, 0.15f);
    }

    void update(float dt) override {
        Entity::update(dt);

        auto& eng = scene().engine();
        const auto& input = eng.input();

        auto* tr = get<rlge::Transform>();
        if (!tr)
            return;

        if (input.down("left"))
            tr->position.x -= speed_ * dt;
        if (input.down("right"))
            tr->position.x += speed_ * dt;
        if (input.down("up"))
            tr->rotation += speed_ * dt;

        // Make camera follow player
        eng.services().camera().follow(tr->position);
    }

    float speed_ = 200.0f;

    friend class GameScene;
};

class GameScene final : public Scene, public HasDebugOverlay {
public:
    explicit GameScene(Engine& e) :
        Scene(e) {}

    void enter() override {
        // Load background and player sprite generated by Python helpers.
        auto& bgTex = engine().assetStore().loadTexture("background", "../examples/basic_game/assets/background.bmp");
        auto& playerTex = engine().assetStore().loadTexture("player", "../examples/basic_game/assets/player.bmp");

        // Draw order: background first, player on top.
        bg_  = &spawn<Background>(bgTex);
        player_ = &spawn<Player>(playerTex);
        fps_ = &spawn<FpsCounter>();
    }

    void debugOverlay() override {
        ImGui::Begin("Game debug");
        ImGui::Text("Number of entities: %d", static_cast<int>(entities().size()));

        if (bg_) {
            ImGui::Checkbox("Show background", &bg_->visible_);
        }

        if (player_) {
            if (auto* tr = player_->get<rlge::Transform>()) {
                ImGui::SliderFloat("Player X", &tr->position.x, -500.f, 500.f);
                ImGui::SliderFloat("Player Y", &tr->position.y, -500.f, 500.f);
                ImGui::SliderFloat("Player rotation", &tr->rotation, 0.f, 360.f);
            }
            ImGui::SliderFloat("Player speed", &player_->speed_, 50.f, 600.f);
        }
        ImGui::End();
    }
private:
    Background* bg_{nullptr};
    Player* player_{nullptr};
    FpsCounter* fps_{nullptr};
};

int main() {
    Engine engine(960, 540, 60, "RLGE Basic Game");

    // Basic input bindings
    engine.input().bind("left", KEY_A);
    engine.input().bind("right", KEY_D);
    engine.input().bind("up", KEY_W);

    // Start with our game scene
    engine.pushScene<GameScene>();
    engine.run();

    return 0;
}
