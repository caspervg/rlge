#include <print>
#include <random>

#include "debug.hpp"
#include "engine.hpp"
#include "imgui.h"
#include "sprite.hpp"
#include "transformer.hpp"
#include "render_entity.hpp"
#include "sprite_sheet.hpp"

using namespace rlge;

constexpr auto TILES_X = 20;
constexpr auto TILES_Y = 15;
constexpr auto PIXELS_PER_TILE = 8;
constexpr auto MAGNIFICATION = 4;
constexpr auto TILE_PIXELS = PIXELS_PER_TILE * MAGNIFICATION;
constexpr auto SCREEN_PIXELS_X = TILES_X * PIXELS_PER_TILE * MAGNIFICATION;
constexpr auto SCREEN_PIXELS_Y = TILES_Y * PIXELS_PER_TILE * MAGNIFICATION;

class FpsCounter final : public RenderEntity {
public:
    explicit FpsCounter(Scene& scene) :
        RenderEntity(scene) {}

    void draw() override {
        rq().submitUI([] {
            DrawRectangle(5, 5, 80, 30, Fade(BLACK, 0.5f));
            DrawFPS(10, 10);
        });
    }
};

// Background entity that draws a wide patterned image so movement is obvious.
class Background final : public RenderEntity {
public:
    explicit Background(Scene& scene, Texture2D& texture) :
        RenderEntity(scene)
        , texture_(texture) {}

    void draw() override {
        if (!visible_)
            return;
        // Draw at world origin; the camera moving will reveal different parts.
        rq().submitBackground([this] {
            DrawTexture(texture_, -texture_.width / 2, -texture_.height / 4, WHITE);
        });
    }

private:
    Texture2D& texture_;
    bool visible_ = true;

    friend class GameScene;
};

class Wall final : public RenderEntity {
public:
    explicit Wall(Scene& scene, SpriteSheet& sheet, int tileX, int tileY) :
        RenderEntity(scene) {
        rng_ = std::default_random_engine(std::random_device{}());

        auto& tr = add<rlge::Transform>();
        tr.position = {
            static_cast<float>(tileX * TILE_PIXELS) - SCREEN_PIXELS_X / 2 + TILE_PIXELS /2,
            static_cast<float>(tileY * TILE_PIXELS) - SCREEN_PIXELS_Y / 2 + TILE_PIXELS /2
        };
        tr.scale = {4, 4};
        tr.rotation = 90.0f * rotationRng_(rng_);

        sprite_ = &add<SheetSprite>(sheet, sheetSpriteColRng_(rng_), 0);
    }

private:
    std::default_random_engine rng_;
    std::uniform_int_distribution<> rotationRng_{0, 3};
    std::uniform_int_distribution<> sheetSpriteColRng_{12, 13};
    SheetSprite* sprite_;
};

// Simple player entity that can move left/right/rotate and is followed by the camera.
class Snake final : public RenderEntity {
public:
    explicit Snake(Scene& scene, SpriteSheet& sheet) :
        RenderEntity(scene) {
        auto& tr = add<rlge::Transform>();
        tr.position = {0, 0};
        tr.scale = {4, 4};

        sprite_ = &add<SheetSprite>(sheet, 1, 3);
    }

    void update(float dt) override {
        Entity::update(dt);

        auto& eng = scene().engine();
        const auto& input = eng.input();

        auto* tr = get<rlge::Transform>();
        if (!tr)
            return;

        if (input.down("left")) {
            tr->position.x -= speed_ * dt;
            sprite_->setTile(2, 3);
            return;
        }
        if (input.down("right")) {
            tr->position.x += speed_ * dt;
            sprite_->setTile(4, 3);
            return;
        }
        if (input.down("up")) {
            tr->position.y -= speed_ * dt;
            sprite_->setTile(1, 3);
            return;
        }
        if (input.down("down")) {
            tr->position.y += speed_ * dt;
            sprite_->setTile(3, 3);
            return;
        }

    }

    float speed_ = 200.0f;
    SheetSprite* sprite_;

    friend class GameScene;
};

class GameScene final : public Scene, public HasDebugOverlay {
public:
    explicit GameScene(Engine& e) :
        Scene(e) {}

    void enter() override {
        // Load background and player sprite generated by Python helpers.
        auto& spriteTex = engine().assetStore().loadTexture("spritesheet", "../examples/snake/assets/spritesheet.png");
        spriteSheet_ = std::make_unique<SpriteSheet>(spriteTex, 8, 8);

        // Draw order: background first, player on top.
        snake_ = &spawn<Snake>(*spriteSheet_);
        fps_ = &spawn<FpsCounter>();
        walls_ = std::vector<Wall*>{};
        for (auto y = 0; y < TILES_Y; ++y) {
            walls_.push_back(&spawn<Wall>(*spriteSheet_, 0, y));
            walls_.push_back(&spawn<Wall>(*spriteSheet_, TILES_X - 1, y));
        }
        for (auto x = 0; x < TILES_X; ++x) {
            walls_.push_back(&spawn<Wall>(*spriteSheet_, x, 0));
            walls_.push_back(&spawn<Wall>(*spriteSheet_, x, TILES_Y - 1));
        }
    }

    void debugOverlay() override {
        ImGui::Begin("Game debug");
        ImGui::Text("Number of entities: %d", static_cast<int>(entities().size()));

        if (snake_) {
            if (auto* tr = snake_->get<rlge::Transform>()) {
                ImGui::SliderFloat("Player X", &tr->position.x, 0, TILES_X * PIXELS_PER_TILE * MAGNIFICATION / 2);
                ImGui::SliderFloat("Player Y", &tr->position.y, 0, TILES_Y * PIXELS_PER_TILE * MAGNIFICATION / 2 );
                ImGui::SliderFloat("Player rotation", &tr->rotation, 0.f, 360.f);
            }
            ImGui::SliderFloat("Player speed", &snake_->speed_, 50.f, 600.f);
        }
        ImGui::End();
    }

private:
    Snake* snake_{nullptr};
    FpsCounter* fps_{nullptr};
    std::vector<Wall*> walls_;
    std::unique_ptr<SpriteSheet> spriteSheet_{nullptr};
};

int main() {
    Engine engine(TILES_X * PIXELS_PER_TILE * MAGNIFICATION, TILES_Y * PIXELS_PER_TILE * MAGNIFICATION, 60,
                  "RLGE Snake");

    // Basic input bindings
    engine.input().bind("left", KEY_A);
    engine.input().bind("right", KEY_D);
    engine.input().bind("up", KEY_W);
    engine.input().bind("down", KEY_S);

    auto& camera = engine.services().camera();
    camera.setOffset({TILES_X * PIXELS_PER_TILE * MAGNIFICATION / 2.0f,
                      TILES_Y * PIXELS_PER_TILE * MAGNIFICATION / 2.0f});
    camera.follow({0.0f, 0.0f}, 1.0f);

    // Start with our game scene
    engine.pushScene<GameScene>();
    engine.run();

    return 0;
}
